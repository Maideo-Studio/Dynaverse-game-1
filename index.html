<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Multiplayer with Scaledrone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #2595f3; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>
<script>
class MultiplayerEngine {
    constructor() {
        this.keys = {};
        this.speed = 0.1;
        this.rotationSpeed = 0.05;
        this.cameraAngle = 0;
        this.cameraDistance = 8;
        this.cameraHeight = 4;

        this.isJumping = false;
        this.velocity_y = 0;
        this.gravity = -0.05;
        this.jumpStrength = 0.8;

        this.players = {}; // Store other players
        this.clientId = Math.random().toString(36).substring(2, 10);

        this.initScene();
        this.initCamera();
        this.initRenderer();
        this.initLights();
        this.initObjects();
        this.initControls();
        this.addResizeListener();
        this.initScaledrone();
        this.animate();
    }

    initScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x2595f3);
    }

    initCamera() {
        this.camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    }

    initRenderer() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(this.renderer.domElement);
    }

    initLights() {
        const ambient = new THREE.AmbientLight(0xffffff, 1.5);
        this.scene.add(ambient);
        const directional = new THREE.DirectionalLight(0xffffff, 2);
        directional.position.set(5, 10, 5);
        this.scene.add(directional);
    }

    initObjects() {
        const loader = new THREE.TextureLoader();

        // Ground
        const groundTexture = loader.load("https://raw.githubusercontent.com/Maideo-Studio/Dynaverse-faces/main/roblox-stud%20(1).png");
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(100, 100);
        groundTexture.magFilter = THREE.NearestFilter;
        const groundMat = new THREE.MeshStandardMaterial({ map: groundTexture });
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        this.ground = new THREE.Mesh(groundGeo, groundMat);
        this.ground.rotation.x = -Math.PI / 2;
        this.ground.position.y = -1.1;
        this.scene.add(this.ground);

        // Player
        this.player = new THREE.Group();
        this.player.position.y = 0.5;
        this.scene.add(this.player);

        const geometry = new THREE.BoxGeometry();
        const faceTexture = loader.load("https://raw.githubusercontent.com/Maideo-Studio/Dynaverse-faces/main/76baf281-4d65-4780-bbec-a7f7b27c9ae7.png");
        faceTexture.magFilter = THREE.NearestFilter;

        const headMaterials = [
            new THREE.MeshStandardMaterial({ color: 0xd524b0 }),
            new THREE.MeshStandardMaterial({ color: 0xd524b0 }),
            new THREE.MeshStandardMaterial({ color: 0xd524b0 }),
            new THREE.MeshStandardMaterial({ color: 0xd524b0 }),
            new THREE.MeshStandardMaterial({ map: faceTexture, color: 0xfc55cc }),
            new THREE.MeshStandardMaterial({ color: 0xd524b0 })
        ];
        this.head = new THREE.Mesh(geometry, headMaterials);
        this.head.scale.set(1.5, 1, 1);
        this.player.add(this.head);

        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x990099 });
        this.body = new THREE.Mesh(geometry, bodyMat);
        this.body.position.set(0, -0.8, 0);
        this.body.scale.set(0.6, 0.6, 0.5);
        this.player.add(this.body);

        const limbMat = new THREE.MeshStandardMaterial({ color: 0xd524b0 });
        this.leftArm = new THREE.Mesh(geometry, limbMat);
        this.leftArm.position.set(-0.41, -0.8, 0);
        this.leftArm.scale.set(0.2, 0.6, 0.3);
        this.player.add(this.leftArm);

        this.rightArm = new THREE.Mesh(geometry, limbMat);
        this.rightArm.position.set(0.41, -0.8, 0);
        this.rightArm.scale.set(0.2, 0.6, 0.3);
        this.player.add(this.rightArm);

        this.leftLeg = new THREE.Mesh(geometry, limbMat);
        this.leftLeg.position.set(-0.2, -1.3, 0);
        this.leftLeg.scale.set(0.2, 0.6, 0.3);
        this.player.add(this.leftLeg);

        this.rightLeg = new THREE.Mesh(geometry, limbMat);
        this.rightLeg.position.set(0.2, -1.3, 0);
        this.rightLeg.scale.set(0.2, 0.6, 0.3);
        this.player.add(this.rightLeg);
    }

    initControls() {
        window.addEventListener("keydown", (e) => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener("keyup", (e) => this.keys[e.key.toLowerCase()] = false);
    }

    initScaledrone() {
        // Replace 'NUQmTa8yqYMpijoa' with your Scaledrone channel ID
        this.drone = new Scaledrone("NUQmTa8yqYMpijoa");
        this.drone.on('open', () => {
            console.log("Connected to Scaledrone");
            this.room = this.drone.subscribe("observable-room");
            this.room.on('data', (data, member) => {
                if (data.id === this.clientId) return; // Ignore self
                if (!this.players[data.id]) {
                    this.players[data.id] = this.createRemotePlayer();
                }
                this.players[data.id].position.set(data.x, data.y, data.z);
                this.players[data.id].rotation.y = data.rotationY;
            });
        });
    }

    createRemotePlayer() {
        const loader = new THREE.TextureLoader();
        const geometry = new THREE.BoxGeometry();
        const headMat = new THREE.MeshStandardMaterial({ color: 0xff00ff });
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x990099 });
        const limbMat = new THREE.MeshStandardMaterial({ color: 0xd524b0 });

        const group = new THREE.Group();

        const head = new THREE.Mesh(geometry, headMat);
        head.scale.set(1.5, 1, 1);
        group.add(head);

        const body = new THREE.Mesh(geometry, bodyMat);
        body.position.set(0, -0.8, 0);
        body.scale.set(0.6, 0.6, 0.5);
        group.add(body);

        const leftArm = new THREE.Mesh(geometry, limbMat);
        leftArm.position.set(-0.41, -0.8, 0);
        leftArm.scale.set(0.2, 0.6, 0.3);
        group.add(leftArm);

        const rightArm = new THREE.Mesh(geometry, limbMat);
        rightArm.position.set(0.41, -0.8, 0);
        rightArm.scale.set(0.2, 0.6, 0.3);
        group.add(rightArm);

        const leftLeg = new THREE.Mesh(geometry, limbMat);
        leftLeg.position.set(-0.2, -1.3, 0);
        leftLeg.scale.set(0.2, 0.6, 0.3);
        group.add(leftLeg);

        const rightLeg = new THREE.Mesh(geometry, limbMat);
        rightLeg.position.set(0.2, -1.3, 0);
        rightLeg.scale.set(0.2, 0.6, 0.3);
        group.add(rightLeg);

        this.scene.add(group);
        return group;
    }

    updateMovement() {
        const forward = new THREE.Vector3();
        this.camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

        let moved = false;
        if (this.keys["w"]) { this.player.position.add(forward.clone().multiplyScalar(this.speed)); moved = true; }
        if (this.keys["s"]) { this.player.position.add(forward.clone().multiplyScalar(-this.speed)); moved = true; }
        if (this.keys["a"]) { this.player.position.add(right.clone().multiplyScalar(-this.speed)); moved = true; }
        if (this.keys["d"]) { this.player.position.add(right.clone().multiplyScalar(this.speed)); moved = true; }

        if (this.keys[" "]) {
            if (!this.isJumping) {
                this.velocity_y = this.jumpStrength;
                this.isJumping = true;
            }
        }

        if (this.isJumping || this.player.position.y > 0.5) {
            this.player.position.y += this.velocity_y;
            this.velocity_y += this.gravity;
        }
        if (this.player.position.y < 0.5) {
            this.player.position.y = 0.5;
            this.isJumping = false;
            this.velocity_y = 0;
        }

        if (moved) {
            const velocity = new THREE.Vector3(0,0,0);
            if (this.keys["w"]) velocity.add(forward);
            if (this.keys["s"]) velocity.add(forward.clone().negate());
            if (this.keys["a"]) velocity.add(right.clone().negate());
            if (this.keys["d"]) velocity.add(right);
            if (velocity.lengthSq() > 0) {
                velocity.normalize();
                this.player.lookAt(this.player.position.clone().add(velocity));
            }
        }

        if (this.keys["e"]) this.cameraAngle -= this.rotationSpeed;
        if (this.keys["q"]) this.cameraAngle += this.rotationSpeed;

        const camX = this.player.position.x + Math.sin(this.cameraAngle) * this.cameraDistance;
        const camZ = this.player.position.z + Math.cos(this.cameraAngle) * this.cameraDistance;
        this.camera.position.set(camX, this.player.position.y + this.cameraHeight, camZ);
        this.camera.lookAt(this.player.position);

        // Send updated position to Scaledrone
        if (this.drone) {
            this.drone.publish({
                room: "observable-room",
                message: {
                    id: this.clientId,
                    x: this.player.position.x,
                    y: this.player.position.y,
                    z: this.player.position.z,
                    rotationY: this.player.rotation.y
                }
            });
        }
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.updateMovement();
        this.renderer.render(this.scene, this.camera);
    }

    addResizeListener() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }
}

new MultiplayerEngine();
</script>
</body>
</html>
